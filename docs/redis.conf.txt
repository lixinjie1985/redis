redis的启动方式，这样可以读取配置文件
./redis-server /path/to/redis.conf

可以使用include包含其它配置文件，如果有相同的配置项，后面的会覆盖前面的
include /path/to/other.conf

可以用bind来限制访问者的IP地址，如果不定义就等于不限制
bind 192.168.1.100 10.0.0.1
bind 127.0.0.1

保护模式是一个安全层保护，打开时只能从回环地址127.0.0.1访问，如果要从其它客户端访问，请关闭它
protected-mode yes

port定义监听端口，默认是6379
port 6379

TCP监听积压，当并发量高时会有积压，请同时配置操作系统的/proc/sys/net/core/somaxconn和redis的tcp_max_syn_backlog
tcp-backlog 511

当客户端空闲指定秒后关系连接，0表示禁用，即不关
timeout 0

TCP存活时间，超过这个时间没有通信的话就会发送心跳检测，默认值300秒
tcp-keepalive 300

默认redis是前台程序，可以设置为守护程序（后台），此时会在/var/run/redis.pid这里写一个pid文件
daemonize no

pid文件指定一个文件位置，当以守护程序运行时会写入进程编号
pidfile /var/run/redis_6379.pid

设置日志级别，debug，verbose，notice，warning，默认适合生产环境级别
loglevel notice

指定日志文件名称，空字符串表示标准输出，如果以守护程序运行且指定了标准输出，其实输出到/dev/null，等于全部丢弃
logfile ""

可以设置启用系统日志器，还可以更新syslog参数以适应自己的需求
syslog-enabled no

指定syslog身份
syslog-ident redis

指定syslog设施，必须是USER或在LOCAL0-LOCAL7之间
syslog-facility local0

设置数据库的个数，默认数据库是DB 0，可以使用SELECT <dbid>命令在每个连接上选择不同的数据库
databases 16

把数据库保存到磁盘，save <seconds> <changes>，表示在指定时间内发生了指定次数的更改操作就触发保存磁盘，不配置或配置成save ""都表示不保存磁盘
save 900 1
save 300 10
save 60 10000

默认当后台保存快照失败时，redis将不再接受写请求，这将使用户感知到（在写失败时）数据没有正确的持久化到磁盘。当下次后台保存成功后，
将自动再次允许写请求。如果自己有相关方面的监控的话，那么在失败时也可以允许写请求
stop-writes-on-bgsave-error yes

启用转储数据库压缩，可以减少数据集大小，但是会消耗一些CPU，默认启动
rdbcompression yes

启用RDB的CRC64循环冗余校验和（将循环冗余校验和放到文件的末尾，禁用时会放置一个0，来告知跳过校验），这种格式将会提高抗腐化能力，但是会降低百分之十左右的性能
rdbchecksum yes

转储DB的文件名称
dbfilename dump.rdb

工作目录，DB转储文件和aof文件都在这个目录里生成，指定的必须是一个目录
dir ./

主从复制是异步的，当连接到一个主节点的从节点个数达不到指定数目时，这个主节点可以配置成停止接受写请求
当主从复制连接丢失时间相对较短时，从节点能够执行局部的再同步（非全量的）。主从复制积压量大小可配置
主从复制是自动进行的，不需要用户干预。在网络分区之后，从节点自动尝试重连主节点进行重同步
slaveof <masterip> <masterport>

如果主节点有密码的话，主从复制前必须指定来认证授权，否则会被拒绝
masterauth <master-password>

当从节点丢失到主节点的连接或和主节点之间的复制正在进行时，从节点可以表现两种不同的行为，一是使用过期的数据响应客户端的请求，
一是直接返回正在同步中（SYNC with master in progress）的错误。默认是第一种
slave-serve-stale-data yes

可以配置从节点是否接受写请求，一个用处是用它来存储非常短暂的临时数据，当它和主节点同步后这些数据就没有了，但应该避免把永久性数据也写到从节点上
slave-read-only yes

新的从节点和正在重连且不能继续复制的从节点，需要一个完全的同步，一个RDB文件从主节点传到从节点，传输方式分两种，一是主节点创建一个新的进程把RDB文件写到磁盘上，
然后由父进程逐渐地传给从节点，一是主节点创建一个新的进程把RDB文件直接写到从节点的socket中，整个过程不涉及磁盘。磁盘较慢且网络带宽很大时，第二种方式较好
repl-diskless-sync no

在无磁盘方式复制时，可以定义一个延迟时间，来让更多的从节点到来，然后同时传给它们，因为一旦开始传输后，新来的从节点将不能再传输，
它们被排队等待下次传输，默认5秒，禁用请设置为0秒
repl-diskless-sync-delay 5

定义从节点向主节点发送心跳的间隔，默认10秒
repl-ping-slave-period 10

定义复制超时时间，在从节点视图，同步时IO传输超时，在从节点视图，主节点超时（数据和ping），在主节点视图，从节点超时（复制配置确认ping），这个值应该比上面那个值大
repl-timeout 60

可以定义是否使用TCP延迟，如果延迟的话，redis将使用少数的包和小带宽发送数据到从节点，这会使数据延迟出现在从节点端，最多延迟40毫秒。如果不延迟的话，
数据出现在从节点端的延迟将减少，但会消耗更多带宽。默认优化为不延迟，但高流量和多跳时建议设为延迟
repl-disable-tcp-nodelay no

设置复制挤压量大小，是一个缓冲区，在从节点断开连接时可以暂时存储数据，当从节点重新连上时，只需要一个部分（局部）的同步就足够，这个值越大，
主从复制能够断开的时间就越长。
repl-backlog-size 1mb

在一个主节点没有从节点连接时，且经过一段时间后，积压缓冲区将被释放，这段时间的长度可以定义，0表示永远不释放
repl-backlog-ttl 3600

从节点优先级是一个整数，在主节点挂时，哨兵程序使用它把要一个从节点提升为主节点，数值越小优先级越高，0表示不参与，即不会成为主节点。默认是100
slave-priority 100

在一个指定的延期时间内，一个主节点的已连接上从节点个数没有达到指定的数目，主节点将停止接受写请求。在最长10秒的延期内至少3个从节点。
任何一个设置为0将禁用这个特性，默认第一个是0，第二个是10
min-slaves-to-write 3
min-slaves-max-lag 10

主节点可以收集从节点的IP和Port，但是当使用端口转发或网络地址转换时，从节点可能使用不同的IP和Port到达，可以自定义IP和Port，用于从节点向主节点报告
slave-announce-ip 5.5.5.5
slave-announce-port 1234

可以设置一个密码，客户端在连接时需要认证授权，密码应当复杂些，因为每秒可以进行15次暴力破解
requirepass foobared

在一个不安全的共享环境中，可以重命名命令，使无法根据名称来猜测，这些命令在内部仍然可以使用，只是不能在客户端使用。当把一个命令重命名为空字符串时，
这个命令将无法再被使用。命令的重命名会记录在AOF文件中，传给从节点时可能会引起问题
rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
rename-command CONFIG ""

设置同时客户端最大连接数，默认是10000，如果redis所在的server无法配置进程文件限制数目来做这个限制，那就设置成当前的文件限制数目减去32
（因为redis保留一些文件描述符用作内部使用），一旦连接达到上限，新的连接将收到已达连接上限错误
maxclients 10000

当使用的内存达到限制时，redis将根据设置的回收策略删除keys。如果回收策略是noeviction或无法删除keys，对于需要占用内存的写请求将报错，
读请求可以继续响应。这适用于redis用作LRU缓存时或回收策略是noeviction时。
maxmemory <bytes>

最大内存策略，当内存用量达到限制时，选择删除什么，有五种策略，volatile-lru：使用LRU算法移除带有超时时间的key，allkeys-lru：使用LRU算法移除任何key，
volatile-random：随机移除带有超时时间的key，allkeys-random：随机移除任何key，volatile-ttl：移除最接近超时时间的key，
noeviction：key永不过期，也不移除，仅仅对于写操作返回错误。不管采用什么策略，当没有适合的keys被回收时，redis对于写操作都返回错误。默认策略是noeviction
maxmemory-policy noeviction

LRU和最小TTL算法都不是精确算法而是估算，可以调整算法执行的速度和精确度，默认会检测5个keys然后选择1一个最近不用的，这已经是一个不错的结果，
如果是10的话将非常接近真实的LRU但是会多消耗些CPU，如果是3的话计算非常快但不是很精确。默认5
maxmemory-samples 5

默认情况redis异步地转储数据集到磁盘上，但是如果进程出问题或停电，将会有几分钟的写操作丢失。aof是一个可选的持久化方式提供更好的耐用性，
采用默认策略时redis只丢失一秒的写操作，例如停电时。如果redis进程出问题的话，只丢失一次写操作。AOF和RDB持久化方案可以同时启用。如果AOF启用，
在启动时redis会去加载AOF文件，这就是该文件有更好耐用性的保证
appendonly no

aof文件的名称，默认是appendonly.aof
appendfilename "appendonly.aof"

不同的操作系统把数据从缓存刷入磁盘的时机和频率不同，redis支持三种方案，no：让操作系统自己决定什么时候刷盘，很快，
always：每次写操作后都刷盘，慢，最安全，everysec：每秒刷盘一次，折中。默认是everysec，是速度和安全的折中。具体采用哪个取决于业务
appendfsync everysec

当刷盘策略设置成always或everysec时，后台保存进程或aof日志文件重写进程会对磁盘执行很多的IO。在一些linux配置下，redis将会在刷盘上被阻塞很长时间，
这个问题现在没有办法修复，即使在另一个线程上执行刷盘，将阻塞对同步写的调用。为了缓解这个问题，当后台进程正在处理中时，将阻止从主进程中调用刷盘。
这意味着当一个孩子正在执行保存，redis看起来像没有在刷盘一样，在实际中，最坏的情况下，这意味着最多丢失30秒的数据。如果有延时问题就设为yes，
否则设为no，从耐用性的角度看这是最安全的选择
no-appendfsync-on-rewrite no

如果AOF日志文件的大小增长了指定的百分比，那么AOF日志文件将自动隐式被重写，可以定义一个百分比，计算出新的文件大小，当日志文件超过这个值时将被重写，
还定义一个重写最小的大小界限，避免文件很小时就被重写。如果百分比设为0的话，将禁用日志文件重新特性
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

redis启动时加载aof日志文件到内存，会发现日志文件尾部可能会被截断，这时有两种方式，一是尽可能多的从aof日志文件中读取数据，然后启动redis，
一是抛出错误，拒绝启动，要求用户使用redis-check-aof工具修复日志文件，然后再重新启动。如果日志文件中间损坏，同样是抛出错误无法启动
aof-load-truncated yes

lua脚本最大执行时间（毫秒），0或负值表示不限制且没有警告
lua-time-limit 5000

redis集群被认为是稳定的代码，但需要在生产中更多的使用来使之成熟。通常的实例节点不能作为集群的一部分，需要启用才行
cluster-enabled yes

集群中的每个节点都有一个集群配置文件，这个文件不需要人编辑，由节点创建和更新。每个节点的集群配置文件都不同，所以文件名称不能重复
cluster-config-file nodes-6379.conf

集群节点超时时间（毫秒），在指定时间内不可达被认为是失败状态，很多内部时间的限制都是超时时间的倍数
cluster-node-timeout 15000

如果一个失败主节点的一个从节点的数据看起来很旧，将避免启动一个故障转移，从节点没有简单的方式来精确衡量它的数据年龄。一是，如果有多个从节点能够故障转移，
它们互相交换信息来给那个具有最好主从复制偏移量的（从主节点接收数据最多的）从节点优势，从节点通过偏移量获得它们的排名，以一个同排名成比例的延迟，
应用到故障转移的启动（先数据多的，后数据少的）。一是，每个从节点计算最后一次同主节点交互的时间，可以是心跳时间，命令接收时间或连接断开后又逝去的时间，
如果时间太旧的话将不进行故障转移。
这里的第二点可以被用户调整，当距离最后一次交互又超过一段时间后将不再故障转移，这段时间的计算公式是
(node-timeout * slave-validity-factor) + repl-ping-slave-period，这个slave-validity-factor的值越大，数据可以越旧。
为了最大可用性，可以把它设为0，表示总是尝试故障转移，不管经过了多长时间
cluster-slave-validity-factor 10

集群从节点能够迁移到孤立的主节点（没有从节点的主节点），这改进了集群抵御失败的能力，否则一个孤立主节点失败时无法进行故障转移。
只有当主节点的从节点个数达到一数目后，多余从节点才可以迁移到孤立主节点，这个数目叫做迁移屏障，也反映出集群中每个主节点想要的从节点数目。
默认是1，如果想禁用的话就设置一个非常大的数值。可以设为0，但仅用于调试，生产用很危险
cluster-migration-barrier 1

默认集群节点停止接受查询，如果它们检测到至少有一个哈希槽没有被覆盖（没有正在为它服务节点），这种方式是如果集群部分宕机，整个集群最终都不可用。
一旦所有的哈希槽都再次被覆盖，集群将自动返回可用。有时希望集群的子集（一部分）可以继续接受查询，为仍然被覆盖的那部分键空间提供服务，请将全覆盖设置为no
cluster-require-full-coverage yes

慢日志是指执行时间超过某个指定的值，不包括IO的时间，即线程阻塞不能响应其它请求的时间，可以配置一个执行时间（微秒），超过它就算慢，还可以指定慢日志的总条数，
当达到限制后，新的慢日志或挤走旧的慢日志记录。当时间是0的话，每条命令都会被当作慢日志，当时间是负数的话，禁用慢日志特性。慢日志的总条数没有限制，但是会消耗内存
slowlog-log-slower-than 10000
slowlog-max-len 128

延时监控子系统可以收集与redis实例延时的可能来源相关的数据，系统只记录执行时间大于等于某个指定值（毫秒）的操作，值为0时关闭延时监控，默认是关闭的
latency-monitor-threshold 0

当key空间里有事件在发生时，redis可以通知发布订阅的客户端，事件的种类有多种，且是可以配置的，空字符串表示禁用通知。至少要指定一个K或E，否则不会有事件分发。默认禁用
notify-keyspace-events ""

哈希类型数据会使用一个高效的数据结构进行编码，只要它里面存的元素条数不超过一个指定的阈值，阈值可配置
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

链表类型数据也可以被编码来节省很多空间，每个内部链表节点允许的条目数可以被指定为一个固定的最大值（KB）或最多存储元素的个数，-5到-1表示从64KB逐次减半到4KB，正数表示能够存储元素的最大数量。-2或-1一般是最高性能选项
list-max-ziplist-size -2

链表可以被压缩，压缩深度指的是从链表两头数不参与压缩的元素数目，链表的头和尾永远不参与压缩，0表示禁用压缩，1表示头和尾不参与但其它都参与压缩，2表示包含头尾在内的最前2个和最后2个不参与但其它都参与压缩，3表示包含头尾在内的最前3个和最后3个不参与但其它都参与压缩
list-compress-depth 0

集合类型数据只有在一种情况下可以被编码，就是它的元素都是字符串，且都是十进制整数，且都在64位有符号整数范围内，可以配置这种集合的大小
set-max-intset-entries 512

有序集合类型数据也可以通过编码节省很多空间，其中集合的大小和单个元素的大小都可以配置
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

HyperLogLog稀疏表示的字节限制，当稀疏表示的字节数超过了这个限制，就会被转化为密实表示，此时会有很多空间没有用。该数据结构的目的是计算去重以后元素的大概数目，但并不存储元素本身
hll-sparse-max-bytes 3000

激活重哈希后CPU时间的一百分之一被用来做重哈希，目的是对字典重哈希且在可能的时候来释放内存。如果激活的话会尽可能快地释放内存，但是会造成一点点（2毫秒）的延时，如果不能忍受延时的话则不要激活
activerehashing yes

客户端输出缓冲区限制，能够快速的强迫客户端断开连接，不再读取来自于服务器的数据（一个原因是服务器产生数据太快，而客户端消费数据太慢）。对于三种不同类型的客户端设置不用，normal：平常客户端，slave：从节点客户端，pubsub：订阅客户端，指令的语法是client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>，一旦硬限制达到立马断开，如果软限制达到且持续指定的时间也断开。默认通常客户端不做限制，因为如果它们不访问就不会收到数据，可能只有异步客户端会遇到数据产生比消费快的情景。默认对于发布订阅和从节点客户端有限制，因为它们会接收从主节点推过来的数据。如果设置为0的话禁用
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

redis调用内部函数来执行一些后台任务，像关闭超时客户端的连接和清除过期的keys，这些任务执行的频率不完全一样，redis根据一个指定的值来检查任务去执行，
这个值越大消耗CPU越多，但是redis响应越灵敏。取值范围1到500，默认10，最好不要超过100，只有在非常低的延时要求下才会超过100
hz 10

当子进程在重写aof日志文件时，如果启用下面设置，文件每增加32M就会刷盘，这会更加逐渐（平稳）避免大的延时尖刺
aof-rewrite-incremental-fsync yes










